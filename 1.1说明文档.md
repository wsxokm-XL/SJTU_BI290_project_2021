版本：1.1 交互式单序列比对版本



特性：一对一的比对DNA序列



源代码：

```c
#include<stdio.h>
#include<string.h>
#define MAXN 100000
int rank[MAXN], sa[MAXN], tax[MAXN], tp[MAXN], Height[MAXN];
//sa[i] ：排名为i的后缀的位置
//rank[i]：从第i个位置开始的后缀的排名
//tax[i]：i号元素出现了多少次，用于基数排序
//tp[i]:第二关键字排名为i的后缀的位置,用于基数排序
void GetHeight(int N,int rank[],int sa[],char s[]);
void SuffixSort(int N,char s[]);
int main() {
char s1[MAXN],s2[MAXN];
char s[MAXN];
printf("s1:\n");
scanf("%s", s1);
int lenofs1=strlen(s1);
printf("s2:\n");
scanf("%s", s2);
int lenofs2=strlen(s2);
strcat(s+1,s1);
strcat(s+1,"@");
strcat(s+1,s2);
int N; //N：字符串s的长度
N = strlen(s+1);
//printf("s:\n%s\n",s+1);
SuffixSort(N,s);
GetHeight(N,rank,sa,s);
int i,link,target; //判断是否分别来自s1,s2
for(i=1;i<=N;i++)
if(rank[i]==1) {link=i; break;}
for(i=1;i<=N;i++)
if(rank[i]==rank[link+1]+1) {target=i; break;}
int j=0;
if(Height[rank[target]]==lenofs2) printf("The location of the firstcharacter is %d\n",target);
else {j++;printf("Not found!\n");}
while(j==0&&rank[target]<N)
{
    for(i=1;i<=N;i++)
    if(rank[i]==rank[target]+1) {target=i;break;}
    if(Height[rank[target]]>=lenofs2) printf("The location of the firstcharacter is %d\n",target);
    else j++;
}
return 0;
}
void GetHeight(int N,int rank[],int sa[],char s[]) {
int i, j, k = 0;
printf("Height[rank[i]]: ");
for( i = 1; i <= N; i++) {
if(k) k--;
j = sa[rank[i] - 1];
while(s[i + k] == s[j + k]) k++;
Height[rank[i]] = k;}
for( i = 1; i <= N; i++)
if(rank[i]==1) Height[rank[i]] = -1;
for( i = 1; i <= N; i++)
printf("%d ",Height[rank[i]]);
printf("\n");
}
void SuffixSort(int N,char s[]) {
int i,w,p; //p：排名，用于基数排序
//w:当前倍增长度
int M = 69; //M ：字符集的大小，即排名的个数，用于基数排序。
for ( i = 1; i <= N; i++) {rank[i] = s[i] - '0' + 1, tp[i] = i;}
//以下4行为基数排序
for (i = 0; i <= M; i++) tax[i] = 0;
for (i = 1; i <= N; i++) tax[rank[i]]++;
for (i = 1; i <= M; i++) tax[i] += tax[i - 1];
for (i = N; i >= 1; i--) sa[ tax[rank[tp[i]]]-- ] = tp[i];
for ( w = 1, p = 0; p < N; M = p, w <= 1) {
p = 0;
for (i = 1; i <= w; i++) tp[++p] = N - w + i;
for (i = 1; i <= N; i++) if (sa[i] > w) tp[++p] = sa[i] - w;
for (i = 0; i <= M; i++) tax[i] = 0;
for (i = 1; i <= N; i++) tax[rank[i]]++;
for (i = 1; i <= M; i++) tax[i] += tax[i - 1];
for (i = N; i >= 1; i--) sa[ tax[rank[tp[i]]]-- ] = tp[i];
memcpy(tp,rank,sizeof(rank));
rank[sa[1]] = p = 1;
for (i = 2; i <= N; i++)
rank[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + w] ==tp[sa[i] + w]) ? p : ++p;
}
printf("sa[i]: ");
for ( i = 1; i <= N; i++)
printf("%d ", sa[i]);
printf("\n");
printf("rank[i]: ");
for ( i = 1; i <= N; i++)
printf("%d ", rank[i]);
printf("\n");
}

```

